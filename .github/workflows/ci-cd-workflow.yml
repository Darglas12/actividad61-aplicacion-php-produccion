name: CI/CD Pipeline - CRUD PHP Application

# Activador: Se ejecuta cada vez que hay un push en main
on:
  push:
    branches:
      - main

# Variables de entorno globales
env:
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
  # Configuraci√≥n espec√≠fica para Darglas12
  AWS_HOST: "3.82.191.151"                   # IP del servidor AWS
  AWS_USER: "ubuntu"                         # Usuario SSH AWS
  AWS_PORT: "22"                             # Puerto SSH
  DOCKER_IMAGE_NAME: "darglas12/crud-php"   # Usuario/Repositorio en DockerHub
  APP_DIRECTORY: "/home/ubuntu/app"          # Directorio donde desplegar en AWS

jobs:
  # ============================================================================
  # STAGE 1: CONTINUOUS INTEGRATION (CI) - BUILDd
  # ============================================================================
  build:
    name: üî® Build Docker Image
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Validate required secrets
        run: |
          echo "Validating required secrets..."
          if [ -z "${{ secrets.DOCKER_USERNAME }}" ] || [ -z "${{ secrets.DOCKER_PASSWORD }}" ]; then
            echo "ERROR: DOCKER_USERNAME and DOCKER_PASSWORD secrets are required for DockerHub login."
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "ERROR: SSH_PRIVATE_KEY secret is required for deployment SSH to AWS."
            exit 1
          fi
          echo "All required secrets present."
      
      - name: Build Docker image
        run: |
          echo "Construyendo imagen Docker desde Dockerfile..."
          cd aplicacion-crud-php-desarrollo-v3
          docker build -t ${{ env.DOCKER_IMAGE_NAME }}:latest .
          docker build -t ${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }} .
          echo "‚úì Imagen construida exitosamente"
      
      - name: Test Docker image
        run: |
          echo "Probando imagen Docker..."
          # El contenedor define ENTRYPOINT ['/usr/sbin/apache2ctl', '-D', 'FOREGROUND']
          # Por eso debemos sobrescribir el entrypoint para ejecutar el comando de prueba
          docker run --rm --entrypoint "" ${{ env.DOCKER_IMAGE_NAME }}:latest /usr/sbin/apache2ctl -v
          echo "‚úì Imagen probada correctamente"

  # ============================================================================
  # STAGE 2: CONTINUOUS DELIVERY (CD) - PUSH TO DOCKERHUB
  # ============================================================================
  push:
    name: üì¶ Push to DockerHub
    runs-on: ubuntu-latest
    needs: build  # Espera a que build termine exitosamente
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to DockerHub (with retries and explicit registry)
        run: |
          set -euo pipefail
          REGISTRY=docker.io
          echo "Attempting Docker login to $REGISTRY with retries..."
          ATTEMPTS=3
          SLEEP_SECONDS=5
          for i in $(seq 1 $ATTEMPTS); do
            echo "Login attempt $i of $ATTEMPTS"
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login --username "${{ secrets.DOCKER_USERNAME }}" --password-stdin $REGISTRY && break || {
              echo "Login attempt $i failed"
              if [ "$i" -lt "$ATTEMPTS" ]; then
                echo "Sleeping $SLEEP_SECONDS seconds before retry..."
                sleep $SLEEP_SECONDS
              else
                echo "All login attempts failed"
                exit 1
              fi
            }
          done
          echo "Docker login successful"
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./aplicacion-crud-php-desarrollo-v3
          push: true
          tags: |
            ${{ env.DOCKER_IMAGE_NAME }}:latest
            ${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }}
            ${{ env.DOCKER_IMAGE_NAME }}:v1.0
          labels: |
            org.opencontainers.image.title="CRUD PHP Application"
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}

  # ============================================================================
  # STAGE 3: CONTINUOUS DEPLOYMENT (CD) - DEPLOY TO AWS
  # ============================================================================
  deploy:
    name: üöÄ Deploy to AWS Production
    runs-on: ubuntu-latest
    needs: push  # Espera a que push termine exitosamente
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Create SSH directory and add identity
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p ${{ env.AWS_PORT }} ${{ env.AWS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
      
      - name: Deploy to AWS via SSH
        run: |
          ssh -i ~/.ssh/id_rsa -p ${{ env.AWS_PORT }} ${{ env.AWS_USER }}@${{ env.AWS_HOST }} << 'EOF'
          
          echo "=========================================="
          echo "  INICIANDO DEPLOYMENT EN PRODUCCI√ìN"
          echo "=========================================="
          
          # Crear directorio de aplicaci√≥n si no existe
          mkdir -p ${{ env.APP_DIRECTORY }}
          cd ${{ env.APP_DIRECTORY }}
          
          # Crear docker-compose.yml si no existe
          if [ ! -f docker-compose.yml ]; then
            echo "Descargando configuraci√≥n de docker-compose..."
            # Opci√≥n 1: Descargar del repositorio
            curl -s https://raw.githubusercontent.com/${{ github.repository }}/main/aplicacion-crud-php-desarrollo-v3/docker-compose.yml -o docker-compose.yml
            # Opci√≥n 2: Si la URL anterior falla, crear uno b√°sico
            if [ ! -f docker-compose.yml ]; then
              cat > docker-compose.yml << 'COMPOSE'
          version: '3.8'
          services:
            nginx-proxy:
              image: ${{ env.DOCKER_IMAGE_NAME }}:latest
              ports:
                - "80:80"
                - "443:443"
              volumes:
                - letsencrypt:/etc/letsencrypt
              restart: unless-stopped
          volumes:
            letsencrypt:
          COMPOSE
            fi
          fi
          
          echo "Deteniendo servicios actuales..."
          docker-compose down || true
          
          echo "Limpiando imagen antigua..."
          docker rmi ${{ env.DOCKER_IMAGE_NAME }}:latest 2>/dev/null || true
          
          echo "Descargando nueva imagen desde DockerHub..."
          docker pull ${{ env.DOCKER_IMAGE_NAME }}:latest
          
          echo "Iniciando servicios..."
          docker-compose up -d
          
          echo "Esperando a que los servicios inicien..."
          sleep 10
          
          echo "Verificando estado de los contenedores..."
          docker-compose ps
          
          echo "=========================================="
          echo "  ‚úì DEPLOYMENT COMPLETADO"
          echo "=========================================="
          
          EOF
      
      - name: Verify deployment
        run: |
          echo "Verificando que la aplicaci√≥n est√° respondiendo..."
          sleep 5
          
          # Intentar conectar al servidor
          ssh -i ~/.ssh/id_rsa -p ${{ env.AWS_PORT }} ${{ env.AWS_USER }}@${{ env.AWS_HOST }} << 'EOF'
          
          echo "Estado de contenedores en producci√≥n:"
          docker-compose ps
          
          echo ""
          echo "Logs recientes:"
          docker-compose logs --tail=20
          
          EOF
      
      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa

  # ============================================================================
  # STAGE 4: NOTIFICACIONES
  # ============================================================================
  notify:
    name: üì¢ Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [build, push, deploy]
    if: always()
    
    steps:
      - name: Deployment Status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ DEPLOYMENT EXITOSO"
            echo "La aplicaci√≥n ha sido desplegada correctamente en:"
            echo "   Servidor: ${{ env.AWS_HOST }}"
            echo "   Imagen: ${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }}"
            exit 0
          else
            echo "‚ùå DEPLOYMENT FALL√ì"
            echo "Revisa los logs para m√°s detalles"
            exit 1
          fi

